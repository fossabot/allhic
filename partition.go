/**
 * Filename: /Users/htang/code/allhic/allhic/partition.go
 * Path: /Users/htang/code/allhic/allhic
 * Created Date: Wednesday, January 3rd 2018, 11:21:45 am
 * Author: htang
 *
 * Copyright (c) 2018 Haibao Tang
 */

package allhic

import (
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
)

// Partitioner converts the bamfile into a matrix of link counts
type Partitioner struct {
	Contigsfile   string
	Distfile      string
	K             int
	contigs       []*ContigInfo
	contigToIdx   map[string]int
	matrix        [][]int64
	longestLength int
}

// Run is the main function body of partition
func (r *Partitioner) Run() {
	r.readRE()
	r.contigToIdx = make(map[string]int)
	for i, ci := range r.contigs {
		r.contigToIdx[ci.name] = i
	}
	dists := r.ParseDist()
	M := r.MakeMatrix(dists)
	r.skipContigsWithFewREs()
	r.skipRepeats()

	clusters := Cluster(M, r.K)

	for _, ids := range clusters {
		names := make([]string, len(ids))
		for i, id := range ids {
			names[i] = r.contigs[id].name
		}
		sort.Strings(names)
		fmt.Println(len(names), strings.Join(names, ","))
	}

	log.Notice("Success")
}

// skipContigsWithFewREs skip contigs with fewere than MinREs
// This reads in the `counts_RE.txt` file generated by extract()
func (r *Partitioner) skipContigsWithFewREs() {
	log.Noticef("skipContigsWithFewREs with MinREs = %d", MinREs)
	nShort := 0
	shortRE := 0
	shortLen := 0

	for _, contig := range r.contigs {
		if contig.recounts < MinREs {
			nShort++
			shortRE += contig.recounts
			shortLen += contig.length
			contig.skip = true
		}
	}
	avgRE, avgLen := 0.0, 0
	if nShort > 0 {
		avgRE, avgLen = float64(shortRE)/float64(nShort), shortLen/nShort
	}
	log.Noticef("Marked %d contigs (avg %.1f RE sites, len %d) since they contain too few REs (MinREs = %d)",
		nShort, avgRE, avgLen, MinREs)
}

// skipRepeats skip contigs likely from repetitive regions. Contigs are repetitive if they have more links
// compared to the average contig. This should be run after contig length normalization.
func (r *Partitioner) skipRepeats() {
	log.Noticef("skipRepeats with multiplicity = %d", MaxLinkDensity)
	// Find the number of Hi-C links on each contig
	totalLinks := int64(0)
	N := len(r.contigs)
	nLinks := make([]int64, N)
	for i := 0; i < N; i++ {
		for j := 1; j < N; j++ {
			counts := r.matrix[i][j]
			totalLinks += counts
			nLinks[i] += counts
		}
	}

	// Determine the threshold to determine whether a contig is 'repetitive'
	nLinksAvg := 2.0 * float64(totalLinks) / float64(N)
	nRepetitive := 0
	repetitiveLength := 0
	for i, contig := range r.contigs {
		factor := float64(nLinks[i]) / nLinksAvg
		// Adjust all ink densitities by their repetitive factors
		for j := 0; j < N; j++ {
			if r.matrix[i][j] != 0 {
				r.matrix[i][j] = int64(math.Ceil(float64(r.matrix[i][j]) / factor))
			}
		}

		if factor >= MaxLinkDensity {
			fmt.Printf("Contig #%d (%s) has %.2f factor x the average number of Hi-C links -> MARKED REPETITIVE",
				i, contig.name, factor)
			nRepetitive++
			repetitiveLength += contig.length
			contig.skip = true
		}
	}

	avgRepetiveLength := 0
	if nRepetitive > 0 {
		avgRepetiveLength = repetitiveLength / nRepetitive
	}

	// Note that the contigs reported as repetitive may have already been marked as skip (e.g. skipContigsWithFewREs)
	log.Noticef("Marked %d contigs (avg len %d) as repetitive (MaxLinkDensity = %d)",
		nRepetitive, avgRepetiveLength, MaxLinkDensity)
}

// MakeMatrix creates an adjacency matrix containing normalized score
func (r *Partitioner) MakeMatrix(edges []ContigPair) [][]int64 {
	M := Make2DSliceInt64(len(r.contigs), len(r.contigs))
	longestSquared := int64(r.longestLength) * int64(r.longestLength)

	// Load up all the contig pairs
	for _, e := range edges {
		a, _ := r.contigToIdx[e.at]
		b, _ := r.contigToIdx[e.bt]
		if a == b {
			continue
		}

		w := int64(e.nObservedLinks) * longestSquared / (int64(e.L1) * int64(e.L2))
		M[a][b] = w
		M[b][a] = w
	}

	return M
}

// ParseDist imports the edges of the contig linkage graph
func (r *Partitioner) ParseDist() []ContigPair {
	pairs := ParseDistLines(r.Distfile)
	// goodPairs := FilterEdges(pairs)
	// log.Noticef("Edge filtering keeps %s edges",
	// 	Percentage(len(goodPairs), len(pairs)))
	goodPairs := pairs
	return goodPairs
}

// FilterEdges implements rules to keep edges between close contigs and remove distant or weak contig pairs
func FilterEdges(edges []ContigPair) []ContigPair {
	var goodEdges []ContigPair

	for _, e := range edges {
		if e.mleDistance >= EffLinkDist {
			continue
		}
		goodEdges = append(goodEdges, e)
	}

	return goodEdges
}

// readRE reads in a three-column tab-separated file
// #Contig    REcounts    Length
func (r *Partitioner) readRE() {
	recs := ReadCSVLines(r.Contigsfile)
	r.longestLength = 0
	for _, rec := range recs {
		name := rec[0]
		recounts, _ := strconv.Atoi(rec[1])
		length, _ := strconv.Atoi(rec[2])
		ci := &ContigInfo{
			name:     name,
			recounts: recounts,
			length:   length,
		}
		if recounts > r.longestLength {
			r.longestLength = recounts
		}
		r.contigs = append(r.contigs, ci)
	}
	log.Noticef("Loading contig RE lengths for normalization from `%s`",
		r.Contigsfile)
}

// ParseContigLines imports the contig infor into a slice of ContigInfo
// ContigInfo stores the data struct of the contigfile
// #Contig Length  Expected        Observed        LDE
// jpcChr1.ctg249  25205   2.3     4       1.7391
// jpcChr1.ctg344  82275   15.4    17      1.1068
func (r *Partitioner) ParseContigLines() {
	recs := ReadCSVLines(r.Contigsfile)
	for _, rec := range recs {
		name := rec[0]
		length, _ := strconv.Atoi(rec[1])
		if length > r.longestLength {
			r.longestLength = length
		}
		nExpectedLinks, _ := strconv.ParseFloat(rec[2], 64)
		nObservedLinks, _ := strconv.Atoi(rec[3])
		lde, _ := strconv.ParseFloat(rec[4], 64)

		ci := &ContigInfo{
			name: name, length: length,
			nExpectedLinks: nExpectedLinks, nObservedLinks: nObservedLinks,
			lde: lde,
		}
		r.contigs = append(r.contigs, ci)
	}
}

// ParseDistLines imports the edges of the contig into a slice of DistLine
// DistLine stores the data structure of the distfile
// #Contig1        Contig2 Length1 Length2 LDE1    LDE2    LDE     ObservedLinks   ExpectedLinksIfAdjacent
// jpcChr1.ctg199  jpcChr1.ctg257  124567  274565  0.3195  2.0838  1.1607  2       27.4
// idcChr1.ctg353  idcChr1.ctg382  143105  270892  2.1577  1.0544  1.3505  2       34.2
func ParseDistLines(distfile string) []ContigPair {
	var edges []ContigPair
	recs := ReadCSVLines(distfile)

	for _, rec := range recs {
		at, bt := rec[0], rec[1]
		RE1, _ := strconv.Atoi(rec[2])
		RE2, _ := strconv.Atoi(rec[3])
		L1, _ := strconv.Atoi(rec[4])
		L2, _ := strconv.Atoi(rec[5])
		lde1, _ := strconv.ParseFloat(rec[6], 64)
		lde2, _ := strconv.ParseFloat(rec[7], 64)
		localLDE, _ := strconv.ParseFloat(rec[8], 64)
		nObservedLinks, _ := strconv.Atoi(rec[9])
		nExpectedLinks, _ := strconv.ParseFloat(rec[10], 64)

		cp := ContigPair{
			at: at, bt: bt,
			RE1: RE1, RE2: RE2,
			L1: L1, L2: L2,
			lde1: lde1, lde2: lde2, localLDE: localLDE,
			nObservedLinks: nObservedLinks, nExpectedLinks: nExpectedLinks,
		}
		fmt.Println(cp)

		edges = append(edges, cp)
	}

	return edges
}
